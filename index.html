<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shadow Hunter - Battle Royale</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Consolas', monospace; touch-action: none; -webkit-tap-highlight-color: transparent; user-select: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .interactive { pointer-events: auto; }
        
        /* Minimapa */
        #minimap-container { position: absolute; top: 20px; left: 20px; width: 120px; height: 120px; background: rgba(0,0,0,0.6); border: 2px solid #ffaa00; border-radius: 50%; overflow: hidden; z-index: 20; }
        #minimap-canvas { width: 100%; height: 100%; }

        /* Joystick - Izquierda Abajo */
        #joystick-container { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; background: rgba(255,255,255,0.05); border-radius: 50%; border: 2px solid rgba(255,255,255,0.1); z-index: 10; }
        #joystick-knob { position: absolute; top: 35px; left: 35px; width: 50px; height: 50px; background: rgba(255, 170, 0, 0.8); border-radius: 50%; box-shadow: 0 0 10px rgba(255,170,0,0.3); }
        
        /* Action Buttons - Grid en rombo */
        #actions-container { position: absolute; bottom: 30px; right: 30px; width: 180px; height: 180px; z-index: 10; }
        
        .skill-btn { position: absolute; border-radius: 50%; background: rgba(0,0,0,0.6); border: 2px solid #555; color: white; display: flex; items-cente: justify-center; font-weight: bold; transition: transform 0.1s; }
        .skill-btn:active { background: #ffaa00; color: black; transform: scale(0.9); }
        .skill-btn:disabled { opacity: 0.3; border-color: #333; }

        /* Posiciones Botones */
        #btn-attack { width: 80px; height: 80px; bottom: 0; right: 0; border-color: #ff4400; font-size: 14px; background: rgba(50, 10, 0, 0.6); } /* Principal */
        #btn-dash { width: 60px; height: 60px; bottom: 20px; right: 90px; border-color: #00aaff; font-size: 10px; } /* Skill 1 */
        #btn-skill2 { width: 50px; height: 50px; bottom: 90px; right: 50px; border-color: #00ff00; font-size: 10px; } /* Skill 2 */
        #btn-skill3 { width: 50px; height: 50px; bottom: 100px; right: 0px; border-color: #aa00ff; font-size: 10px; } /* Skill 3 */

        /* Floating Text */
        .damage-text { position: absolute; color: red; font-weight: 900; font-size: 18px; pointer-events: none; animation: floatUp 0.8s forwards; text-shadow: 2px 2px 0 #000; }
        .xp-text { position: absolute; color: gold; font-weight: 900; font-size: 20px; pointer-events: none; animation: floatUp 1.5s forwards; text-shadow: 2px 2px 0 #000; }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-60px) scale(1.2); } }

        /* HP Bars (HTML Overlay for Enemies) */
        .hp-container { position: absolute; width: 40px; height: 6px; background: red; pointer-events: none; transform: translate(-50%, -50%); display: none; border: 1px solid black; }
        .hp-fill { height: 100%; background: #00ff00; width: 100%; }
    </style>
</head>
<body>

<div id="ui-layer">
    <!-- Lobby -->
    <div id="lobby" class="flex flex-col items-center justify-center h-full bg-slate-900 interactive z-50">
        <h1 class="text-5xl mb-2 font-black text-white italic tracking-tighter text-center">SHADOW<br><span class="text-yellow-500">HUNTER</span></h1>
        <p class="text-gray-400 mb-8 text-xs tracking-widest">BATTLE ROYALE - SOLO MODE</p>
        
        <div class="flex gap-4 mb-8">
            <button onclick="startGame('WARRIOR')" class="bg-red-900 border-2 border-red-500 p-4 w-32 text-center hover:bg-red-800 transition">
                <div class="text-white font-bold text-lg">GUERRERO</div>
                <div class="text-[10px] text-red-300">Daño Melé Alto</div>
            </button>
            <button onclick="startGame('SCOUT')" class="bg-green-900 border-2 border-green-500 p-4 w-32 text-center hover:bg-green-800 transition">
                <div class="text-white font-bold text-lg">TIRADOR</div>
                <div class="text-[10px] text-green-300">Velocidad Alta</div>
            </button>
        </div>
        <button onclick="toggleFullScreen()" class="text-yellow-600 text-xs underline mt-4">ACTIVAR PANTALLA COMPLETA</button>
    </div>

    <!-- HUD -->
    <div id="hud" class="hidden h-full w-full">
        <!-- Minimapa -->
        <div id="minimap-container">
            <canvas id="minimap-canvas" width="150" height="150"></canvas>
        </div>

        <!-- Barras Jugador (Top Center) -->
        <div class="absolute top-4 left-1/2 -translate-x-1/2 w-64 flex flex-col gap-1">
            <div class="w-full h-5 bg-gray-900 border-2 border-gray-600 relative">
                <div id="player-hp-bar" class="h-full bg-gradient-to-r from-red-600 to-red-500 transition-all duration-200" style="width: 100%;"></div>
                <span id="player-hp-text" class="absolute inset-0 flex items-center justify-center text-[10px] font-bold text-white text-shadow">100/100</span>
            </div>
            <div class="flex justify-between text-yellow-500 font-bold text-xs bg-black/50 px-2 py-1 rounded">
                <span>LVL <span id="lvl-val">1</span></span>
                <span>XP <span id="xp-val">0</span></span>
            </div>
        </div>

        <!-- Controles -->
        <div id="joystick-container" class="interactive">
            <div id="joystick-knob"></div>
        </div>

        <div id="actions-container" class="interactive">
            <button id="btn-attack" class="skill-btn" onpointerdown="playerAttack()">ATK</button>
            <button id="btn-dash" class="skill-btn" onpointerdown="useSkill('dash')">DASH</button>
            <button id="btn-skill2" class="skill-btn" onpointerdown="useSkill('spin')">GIRAR</button>
            <button id="btn-skill3" class="skill-btn" onpointerdown="useSkill('heal')">CURAR</button>
        </div>
    </div>
</div>

<script>
    // --- CONFIGURACIÓN GLOBAL ---
    const CONFIG = {
        worldSize: 100,
        enemyCount: 15, // Más enemigos para más caos
        respawnTime: 4000
    };

    let scene, camera, renderer, clock;
    let player, enemies = [], obstacles = [];
    let isGameRunning = false;
    
    // Joystick State
    let joystick = { active: false, x: 0, y: 0, startX: 0, startY: 0 };
    
    // Player Stats
    let stats = {
        hp: 100, maxHp: 100,
        xp: 0, lvl: 1,
        speed: 0.15,
        dmg: 15,
        role: 'WARRIOR',
        cooldowns: { dash: 0, spin: 0, heal: 0 }
    };

    // --- INICIALIZACIÓN ---
    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Iluminación
        const ambLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambLight);
        
        const dirLight = new THREE.DirectionalLight(0xffaa00, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; 
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        clock = new THREE.Clock();
        
        createMap();
        setupInputs();
        animate();
    }

    function createMap() {
        // Suelo
        const floorGeo = new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Muros Límite (Visuales)
        const wallMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
        const wallGeo = new THREE.CylinderGeometry(CONFIG.worldSize/2, CONFIG.worldSize/2, 10, 32, 1, true);
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.y = 5;
        scene.add(wall);

        // Obstáculos
        for(let i=0; i<30; i++) {
            const w = 2 + Math.random()*3;
            const h = 3 + Math.random()*5;
            const d = 2 + Math.random()*3;
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const mesh = new THREE.Mesh(geo, mat);
            
            const x = (Math.random()-0.5) * (CONFIG.worldSize - 10);
            const z = (Math.random()-0.5) * (CONFIG.worldSize - 10);
            
            mesh.position.set(x, h/2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Hitbox Data
            mesh.userData = { isObstacle: true, radius: Math.max(w,d)/1.8 };
            obstacles.push(mesh);
            scene.add(mesh);
        }
    }

    // --- ENTIDADES ---
    function createUnit(isPlayer, role, pos) {
        const group = new THREE.Group();
        const color = isPlayer ? (role === 'WARRIOR' ? 0xff3333 : 0x33ff33) : 0xaaaaaa; // Enemigos grises al inicio
        
        // Modelo simple
        const bodyGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
        const bodyMat = new THREE.MeshStandardMaterial({ color: color });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.75;
        body.castShadow = true;
        group.add(body);

        const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        head.position.set(0, 1.6, 0.3); // Ojos al frente
        group.add(head);

        // Barra de Vida 2D (Sprite/Plane que siempre mira a camara)
        if (!isPlayer) {
            const barBg = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.2), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            barBg.position.y = 2.5;
            group.add(barBg);
            
            const barFg = new THREE.Mesh(new THREE.PlaneGeometry(1.1, 0.15), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            barFg.position.y = 2.5;
            barFg.position.z = 0.01;
            group.userData.hpMesh = barFg; // Referencia para escalar
            group.add(barFg);
            
            // Randomizar stats enemigos
            const lvl = Math.floor(Math.random() * 3) + 1;
            group.userData = {
                id: Math.random(),
                isEnemy: true,
                hp: 50 * lvl,
                maxHp: 50 * lvl,
                dmg: 5 * lvl,
                lvl: lvl,
                speed: 0.08 + (Math.random()*0.04),
                lastAttack: 0,
                target: null // A quién quiere matar
            };
            
            // Color por nivel
            if(lvl > 2) bodyMat.color.setHex(0x5500aa); // Élite
        }

        group.position.copy(pos);
        scene.add(group);
        return group;
    }

    // --- GAMEPLAY LOOP ---
    function startGame(role) {
        document.getElementById('lobby').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        
        stats.role = role;
        if(role === 'SCOUT') { stats.speed = 0.2; stats.dmg = 10; stats.hp = 80; stats.maxHp = 80; }
        
        player = createUnit(true, role, new THREE.Vector3(0, 0, 0));
        
        // Spawneamos enemigos
        for(let i=0; i<CONFIG.enemyCount; i++) respawnEnemy();
        
        isGameRunning = true;
    }

    function respawnEnemy() {
        const x = (Math.random()-0.5) * (CONFIG.worldSize - 5);
        const z = (Math.random()-0.5) * (CONFIG.worldSize - 5);
        const en = createUnit(false, 'WARRIOR', new THREE.Vector3(x, 0, z));
        enemies.push(en);
    }

    function handleEnemyAI() {
        const allUnits = [player, ...enemies]; // Todos son objetivos potenciales
        
        enemies.forEach(en => {
            if(en.userData.hp <= 0) return;

            // 1. Buscar objetivo más cercano
            let closest = null;
            let minDist = 999;

            allUnits.forEach(target => {
                if(target === en) return; // No atacarse a sí mismo
                if(target === player && stats.hp <= 0) return; // Ignorar jugador muerto
                if(target.userData.isEnemy && target.userData.hp <= 0) return; // Ignorar enemigos muertos

                const d = en.position.distanceTo(target.position);
                if(d < 20 && d < minDist) { // Radio de visión
                    minDist = d;
                    closest = target;
                }
            });

            // 2. Moverse o Atacar
            if(closest) {
                // Orientación de la barra de vida (Billboard)
                en.userData.hpMesh.parent.lookAt(camera.position); 
                
                const dist = en.position.distanceTo(closest.position);
                
                if(dist > 1.2) {
                    // Perseguir
                    const dir = new THREE.Vector3().subVectors(closest.position, en.position).normalize();
                    const newPos = en.position.clone().addScaledVector(dir, en.userData.speed);
                    
                    if(!checkCollisions(newPos, en)) {
                        en.position.copy(newPos);
                        en.lookAt(closest.position);
                    }
                } else {
                    // Atacar
                    const now = Date.now();
                    if(now - en.userData.lastAttack > 1500) { // Cooldown ataque
                        en.userData.lastAttack = now;
                        // Animación visual de golpe
                        performAttackVisual(en);
                        
                        // Aplicar daño
                        if(closest === player) {
                            takeDamage(en.userData.dmg);
                        } else {
                            damageEnemy(closest, en.userData.dmg, false);
                        }
                    }
                }
            } else {
                // Patrullar si no hay nadie
                // (Implementación simple: quedarse quieto o moverse random)
            }
        });
    }

    function checkCollisions(pos, self) {
        // Límites del mapa (Circular)
        if(pos.length() > CONFIG.worldSize/2 - 1) return true;

        // Obstáculos
        for(let obs of obstacles) {
            const dx = pos.x - obs.position.x;
            const dz = pos.z - obs.position.z;
            const dist = Math.sqrt(dx*dx + dz*dz);
            if(dist < (0.5 + obs.userData.radius)) return true;
        }

        // Otras unidades (Evitar superposición)
        for(let other of enemies) {
            if(other === self || other.userData.hp <= 0) continue;
            if(pos.distanceTo(other.position) < 1.0) return true;
        }
        
        if(self !== player && pos.distanceTo(player.position) < 1.0) return true;

        return false;
    }

    // --- SISTEMA DE COMBATE ---
    
    function playerAttack() {
        if(!isGameRunning) return;
        performAttackVisual(player);

        // Detectar enemigos en cono frontal
        const range = 3;
        const angleLimit = Math.PI / 3; // 60 grados
        const pDir = new THREE.Vector3(0,0,1).applyQuaternion(player.quaternion);

        enemies.forEach(en => {
            const dist = player.position.distanceTo(en.position);
            if(dist < range) {
                const enDir = new THREE.Vector3().subVectors(en.position, player.position).normalize();
                const angle = pDir.angleTo(enDir);
                if(angle < angleLimit) {
                    damageEnemy(en, stats.dmg, true);
                }
            }
        });
    }

    function useSkill(type) {
        const now = Date.now();
        if(now < stats.cooldowns[type]) return; // Cooldown check

        if(type === 'dash') {
            if(stats.lvl < 2) return showFloatingText("¡Necesitas Nivel 2!", player.position, 'white');
            
            // Impulso vectorial (no depende del joystick actual)
            const dashDir = new THREE.Vector3(0,0,1).applyQuaternion(player.quaternion);
            const targetPos = player.position.clone().addScaledVector(dashDir, 5);
            
            if(!checkCollisions(targetPos, player)) {
                player.position.copy(targetPos); // Teleport corto (Dash instantáneo)
            }
            stats.cooldowns.dash = now + 2000; // 2s CD
        } 
        else if (type === 'spin') {
            // Ataque área
             enemies.forEach(en => {
                if(player.position.distanceTo(en.position) < 4) damageEnemy(en, stats.dmg * 1.5, true);
            });
            createEffect('spin', player.position);
        }
        else if (type === 'heal') {
            stats.hp = Math.min(stats.hp + 30, stats.maxHp);
            updateHUD();
            createEffect('heal', player.position);
        }
    }

    function damageEnemy(en, amount, fromPlayer) {
        en.userData.hp -= amount;
        
        // Actualizar barra visual
        const pct = Math.max(0, en.userData.hp / en.userData.maxHp);
        en.userData.hpMesh.scale.x = pct;
        
        // Texto flotante
        if(fromPlayer) showFloatingText(`-${Math.floor(amount)}`, en.position, 'red');

        if(en.userData.hp <= 0) {
            killEnemy(en, fromPlayer);
        }
    }

    function killEnemy(en, killedByPlayer) {
        en.position.y = -100; // Ocultar bajo tierra
        
        if(killedByPlayer) {
            const xp = en.userData.lvl * 20;
            stats.xp += xp;
            showFloatingText(`+${xp} XP`, player.position, 'gold');
            checkLevelUp();
        }

        // Respawn tras tiempo
        setTimeout(() => {
            scene.remove(en); // Limpiar memoria de ThreeJS idealmente
            const idx = enemies.indexOf(en);
            if(idx > -1) enemies.splice(idx, 1);
            respawnEnemy();
        }, CONFIG.respawnTime);
    }

    function takeDamage(amount) {
        stats.hp -= amount;
        showFloatingText(`-${Math.floor(amount)}`, player.position, 'red');
        updateHUD();
        if(stats.hp <= 0) {
            alert("¡HAS MUERTO! Refrescando...");
            location.reload();
        }
    }

    function checkLevelUp() {
        if(stats.xp >= stats.lvl * 100) {
            stats.xp -= stats.lvl * 100;
            stats.lvl++;
            stats.maxHp += 20;
            stats.hp = stats.maxHp;
            stats.dmg += 5;
            showFloatingText("¡LEVEL UP!", player.position, 'yellow');
            updateHUD();
        }
        updateHUD();
    }

    // --- VISUALES & UI ---
    function performAttackVisual(unit) {
        // Simple movimiento hacia adelante y atrás
        const initial = unit.children[0].position.z; // Asumiendo cilindro
        unit.children[0].position.z += 0.5;
        setTimeout(() => unit.children[0].position.z = initial, 100);
    }

    function createEffect(type, pos) {
        const color = type === 'heal' ? 0x00ff00 : 0xffff00;
        const geo = new THREE.RingGeometry(0.5, 3, 32);
        const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI/2;
        mesh.position.copy(pos);
        mesh.position.y = 0.5;
        scene.add(mesh);
        
        // Animación simple escala
        let s = 1;
        const interval = setInterval(() => {
            s += 0.1;
            mesh.scale.set(s,s,s);
            mesh.material.opacity -= 0.1;
            if(mesh.material.opacity <= 0) {
                clearInterval(interval);
                scene.remove(mesh);
            }
        }, 50);
    }

    function showFloatingText(text, pos, className) {
        const el = document.createElement('div');
        el.className = className === 'gold' ? 'xp-text' : 'damage-text';
        if(className === 'white') el.style.color = 'white';
        el.innerText = text;
        document.body.appendChild(el);

        // Proyectar coordenadas
        const vec = pos.clone();
        vec.y += 2;
        vec.project(camera);
        
        const x = (vec.x * .5 + .5) * window.innerWidth;
        const y = (-(vec.y * .5) + .5) * window.innerHeight;
        
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        
        setTimeout(() => el.remove(), 1500);
    }

    function updateMinimap() {
        const c = document.getElementById('minimap-canvas');
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,150,150);

        // Centro (Jugador)
        const centerX = 75;
        const centerY = 75;
        const scale = 1.5; // Zoom del mapa

        // Dibujar Jugador
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 3, 0, Math.PI*2);
        ctx.fill();

        // Dibujar Enemigos
        ctx.fillStyle = '#ff0000';
        enemies.forEach(en => {
            if(en.userData.hp <= 0) return;
            
            // Posición relativa al jugador
            const dx = (en.position.x - player.position.x) * scale;
            const dz = (en.position.z - player.position.z) * scale;
            
            // Dibujar solo si está dentro del radar
            if(Math.abs(dx) < 75 && Math.abs(dz) < 75) {
                ctx.beginPath();
                ctx.arc(centerX + dx, centerY + dz, 2, 0, Math.PI*2);
                ctx.fill();
            }
        });
    }

    function updateHUD() {
        const pct = (stats.hp / stats.maxHp) * 100;
        document.getElementById('player-hp-bar').style.width = pct + '%';
        document.getElementById('player-hp-text').innerText = `${Math.floor(stats.hp)}/${stats.maxHp}`;
        document.getElementById('lvl-val').innerText = stats.lvl;
        document.getElementById('xp-val').innerText = Math.floor(stats.xp);
        
        // Habilitar botones
        document.getElementById('btn-dash').disabled = stats.lvl < 2;
    }

    // --- INPUTS ---
    function setupInputs() {
        const stick = document.getElementById('joystick-container');
        const knob = document.getElementById('joystick-knob');
        
        stick.addEventListener('touchstart', e => {
            e.preventDefault(); // Evitar scroll
            const touch = e.touches[0];
            const rect = stick.getBoundingClientRect();
            joystick.active = true;
            joystick.startX = rect.left + rect.width/2;
            joystick.startY = rect.top + rect.height/2;
            updateJoystick(touch.clientX, touch.clientY);
        }, {passive: false});

        stick.addEventListener('touchmove', e => {
            e.preventDefault();
            if(joystick.active) updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        const endStick = () => {
            joystick.active = false;
            joystick.x = 0;
            joystick.y = 0;
            knob.style.transform = `translate(0px, 0px)`;
        };
        stick.addEventListener('touchend', endStick);
        stick.addEventListener('touchcancel', endStick);

        function updateJoystick(clientX, clientY) {
            const maxDist = 40;
            let dx = clientX - joystick.startX;
            let dy = clientY - joystick.startY;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
            const angle = Math.atan2(dy, dx);
            
            joystick.x = (Math.cos(angle) * dist) / maxDist;
            joystick.y = (Math.sin(angle) * dist) / maxDist;
            
            knob.style.transform = `translate(${joystick.x * maxDist}px, ${joystick.y * maxDist}px)`;
        }

        // Teclado (Debug PC)
        window.addEventListener('keydown', e => {
            if(e.key === ' ') useSkill('dash');
            if(e.key === 'Enter') playerAttack();
        });
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        }
    }

    // --- LOOP PRINCIPAL ---
    function animate() {
        requestAnimationFrame(animate);
        if(!isGameRunning) return;

        // Movimiento Jugador
        if(joystick.active) {
            const moveSpeed = stats.speed;
            const moveVec = new THREE.Vector3(joystick.x, 0, joystick.y).normalize().multiplyScalar(moveSpeed);
            const newPos = player.position.clone().add(moveVec);
            
            if(!checkCollisions(newPos, player)) {
                player.position.add(moveVec);
                // Rotar hacia donde camina
                player.rotation.y = Math.atan2(-joystick.x, -joystick.y) + Math.PI; 
            }
        }

        // Cámara sigue al jugador
        camera.position.x = player.position.x;
        camera.position.z = player.position.z + 15;
        camera.position.y = 20;
        camera.lookAt(player.position);

        handleEnemyAI();
        updateMinimap();

        renderer.render(scene, camera);
    }

    window.onload = init;
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
