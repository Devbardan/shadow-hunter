<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Shadow Hunter - Mobile Souls</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Consolas", monospace;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
      }
      canvas {
        display: block;
      }
      /* Efecto de Grano de Pel铆cula / Ruido */
      .film-grain {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: none; /* Vital para no bloquear el joystick o botones */
        z-index: 5; /* Por encima del canvas 3D, pero debajo de tu HUD (que usa 10 y 50) */
        opacity: 0.12; /* Ajusta la intensidad (0.05 a 0.2 es lo ideal) */
        background-image: url('data:image/svg+xml,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)"/%3E%3C/svg%3E');
      }
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .interactive {
        pointer-events: auto;
      }

      /* Joystick Styles - Izquierda Abajo */
      #joystick-container {
        position: absolute;
        bottom: 50px;
        left: 40px;
        width: 120px;
        height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 20;
        /* NUEVO: Transici贸n suave y opacidad baja por defecto */
        opacity: 0.3; 
        transition: opacity 0.2s ease-out;
      }
      #joystick-knob {
        position: absolute;
        top: 35px;
        left: 35px;
        width: 50px;
        height: 50px;
        background: #ffaa00;
        border-radius: 50%;
        box-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
      }

      /* Actions Container - Derecha Abajo */
      #actions-container {
        position: absolute;
        bottom: 50px;
        right: 40px;
        display: flex;
        gap: 20px;
        align-items: center;
        z-index: 10;
      }

      /* Action Buttons */
      .action-btn {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid #ffaa00;
        display: flex;
        items-center: justify-center;
        color: #ffaa00;
        font-weight: bold;
        font-size: 14px;
        transition: all 0.1s;
      }
      .action-btn:active,
      .btn-active {
        background: #ffaa00;
        color: #000;
        transform: scale(0.95);
      }
      .btn-disabled {
        opacity: 0.3;
        border-color: #555;
        color: #555;
        pointer-events: none;
      }

      /* Bot贸n Dash m谩s peque帽o */
      .skill-btn-style {
        width: 60px;
        height: 60px;
        font-size: 10px;
        border-color: #00aaff;
        color: #00aaff;
      }

      .stat-btn {
        background: #444;
        color: #fff;
        padding: 4px 12px;
        border-radius: 4px;
        font-weight: bold;
      }
      .quest-card {
        background: rgba(10, 10, 10, 0.95);
        border: 1px solid #ffaa00;
        box-shadow: 0 0 20px rgba(0, 0, 0, 1);
      }

      /* Damage Text Animation */
      .damage-text {
        position: absolute;
        color: red;
        font-weight: bold;
        font-size: 20px;
        pointer-events: none;
        animation: floatUp 1s forwards;
        text-shadow: 1px 1px 0 #000;
      }
      .xp-text {
        position: absolute;
        color: gold;
        font-weight: bold;
        font-size: 20px;
        pointer-events: none;
        animation: floatUp 1.5s forwards;
        text-shadow: 1px 1px 0 #000;
      }
      @keyframes floatUp {
        0% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(-50px);
        }
      }
    </style>
  </head>
  <body>
    <div id="ui-layer">
      <div class="film-grain"></div>
      <!-- Men煤 Principal -->
      <div
        id="lobby"
        class="flex flex-col items-center justify-center h-full bg-slate-900 interactive"
      >
        <h1 class="text-4xl mb-2 font-black text-white italic tracking-tighter">
          SHADOW HUNTER
        </h1>
        <p class="text-yellow-500 mb-8 font-bold text-[10px] tracking-[0.2em]">
          MOBILE BATTLE RPG
        </p>

        <div class="flex flex-col gap-4 w-64">
          <button
            onclick="startGame('WARRIOR')"
            class="bg-black border-2 border-red-700 p-4 text-white hover:bg-red-900 transition-all"
          >
            <span class="block font-bold">ESPADACHN</span>
            <span class="text-[10px] text-red-400">DASH & FUERZA</span>
          </button>
          <button
            onclick="startGame('SCOUT')"
            class="bg-black border-2 border-green-700 p-4 text-white hover:bg-green-900 transition-all"
          >
            <span class="block font-bold">TIRADOR</span>
            <span class="text-[10px] text-green-400">VELOCIDAD & DUALS</span>
          </button>
        </div>
        <div class="mt-8 text-gray-500 text-[10px] text-center">
          <p class="mb-2">CONTROLES PC</p>
          <p>WASD: Mover | ESPACIO: Dash (Lvl 2+)</p>
          <p>ENTER / CLICK: Atacar</p>
        </div>
        <button
          onclick="toggleFullScreen()"
          class="mt-4 text-yellow-600 text-[10px] underline"
        >
          PANTALLA COMPLETA
        </button>
      </div>

      <!-- HUD M贸vil -->
      <div
        id="hud"
        class="hidden h-full w-full flex flex-col justify-between p-4"
      >
        <!-- Superior: HP y Niveles -->
        <div class="flex justify-between items-start">
          <div class="flex flex-col gap-1">
            <div class="flex items-center gap-2">
              <div
                class="w-40 h-4 bg-gray-900 border border-gray-700 overflow-hidden relative"
              >
                <div
                  id="hp-bar"
                  class="h-full bg-red-600 transition-all duration-200"
                  style="width: 100%"
                ></div>
                <span
                  id="hp-text"
                  class="absolute inset-0 text-[10px] text-white flex items-center justify-center font-bold"
                  >100/100</span
                >
              </div>
            </div>
            <div class="flex items-center gap-2">
              <div
                class="w-32 h-2 bg-gray-900 border border-gray-700 overflow-hidden"
              >
                <div
                  id="stamina-bar"
                  class="h-full bg-green-600"
                  style="width: 100%"
                ></div>
              </div>
            </div>
            <div class="text-[10px] text-yellow-500 font-bold mt-1">
              LVL <span id="lvl-val">1</span> | ALMAS:
              <span id="xp-val">0</span>
            </div>
          </div>

          <button
            onclick="toggleStats()"
            class="interactive bg-black/50 border border-yellow-600 p-2 text-yellow-500 text-[10px] font-bold hover:bg-black"
          >
            ATRIBUTOS
          </button>
        </div>

        <!-- Centro: Panel de Atributos (Modal M贸vil) -->
        <div
          id="attr-panel"
          class="hidden self-center bg-black/90 border-2 border-yellow-600 p-6 text-white interactive w-72"
        >
          <div class="flex justify-between mb-4">
            <h3 class="font-bold text-sm uppercase">Mejorar Personaje</h3>
            <button onclick="toggleStats()" class="text-red-500 font-bold">
              X
            </button>
          </div>
          <div class="flex flex-col gap-4">
            <div class="flex justify-between items-center">
              <span>VIGOR (HP)</span>
              <div class="flex items-center gap-4">
                <span id="stat-vig">10</span>
                <button onclick="upgradeStat('vig')" class="stat-btn">+</button>
              </div>
            </div>
            <div class="flex justify-between items-center">
              <span>FUERZA (DMG)</span>
              <div class="flex items-center gap-4">
                <span id="stat-str">10</span>
                <button onclick="upgradeStat('str')" class="stat-btn">+</button>
              </div>
            </div>
            <div class="flex justify-between items-center">
              <span>DESTREZA (SPD)</span>
              <div class="flex items-center gap-4">
                <span id="stat-dex">10</span>
                <button onclick="upgradeStat('dex')" class="stat-btn">+</button>
              </div>
            </div>
            <p class="text-[10px] text-yellow-600 text-center mt-2">
              COSTO: 100 ALMAS
            </p>
          </div>
        </div>

        <!-- Inferior: Controles T谩ctiles (Posicionamiento Absoluto) -->

        <!-- Joystick Izquierda -->
        <div id="joystick-container" class="interactive">
          <div id="joystick-knob"></div>
        </div>

        <!-- Botones Derecha -->
        <div id="actions-container" class="interactive">
          <div class="relative">
            <button
              id="skill-btn"
              class="action-btn skill-btn-style btn-disabled"
            >
              DASH
            </button>
            <span
              id="lock-icon"
              class="absolute -top-2 -right-2 bg-red-600 text-white text-[10px] px-1 rounded-full"
              > Lvl 2</span
            >
          </div>
          <button
            id="attack-btn"
            class="action-btn"
            style="border-color: #ff4400; color: #ff4400"
          >
            ATK
          </button>
        </div>

        <!-- Modal de Quest -->
        <div
          id="quest-notifier"
          class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 quest-card p-6 interactive w-[85%] max-w-sm text-white z-50"
        >
          <p
            id="quest-title"
            class="text-yellow-500 font-bold text-lg mb-2 italic"
          ></p>
          <p id="quest-desc" class="text-xs text-gray-400 mb-6"></p>
          <div class="flex gap-2">
            <button
              onclick="acceptQuest()"
              class="flex-1 bg-yellow-600 text-black font-bold py-3 text-sm hover:bg-yellow-500"
            >
              ACEPTAR PODER
            </button>
            <button
              onclick="closeQuest()"
              class="px-4 bg-gray-800 text-white font-bold py-3 text-sm hover:bg-gray-700"
            >
              IGNORAR
            </button>
          </div>
        </div>
      </div>
      <div id="game-over-screen" class="hidden absolute top-0 left-0 w-full h-full bg-black bg-opacity-90 flex flex-col justify-center items-center z-50 pointer-events-auto">
        <h1 class="text-6xl font-bold text-red-600 mb-8 font-serif tracking-widest" style="text-shadow: 2px 2px 10px #ff0000;">ESTS MUERTO</h1>
        <p class="text-gray-400 mb-8 text-xl">Tu alma se ha desvanecido en la niebla...</p>
        <button onclick="location.reload()" class="px-8 py-4 bg-transparent border-2 border-red-600 text-red-600 text-xl font-bold hover:bg-red-600 hover:text-white transition-all cursor-pointer">
          VOLVER A INTENTAR
        </button>
      </div>
    </div>

    <script>
      const ROLES = {
        WARRIOR: {
          skillName: "DASH",
          color: 0x8b0000, // Rojo oscuro
          speed: 0.15,
          baseDmg: 25
        },
        SCOUT: {
          skillName: "DASH",
          color: 0x228b22, // Verde bosque
          speed: 0.22,
          baseDmg: 15
        }
      };
      
      let scene, camera, renderer, player, clock;
      let enemies = [];
      let worldSize = 120;
      let MAP_SIZE = 100;
      let obstacles = [];
      let isGameRunning = false;
      let currentCamp = null;
      let keys = {};
      let swordPivot;
      let isAttacking = false;
      let attackProgress = 0;
      let damageDealtThisSwing = false;
      const attackSpeed = 0.08;
      let isDashing = false;
      let dashProgress = 0;
      let dashDir = new THREE.Vector3();

      // Variable para el temblor de c谩mara (Seguro para multijugador)
      let shakeTime = 0;


      // Estado del Jugador
      let playerStats = {
        lvl: 1,
        xp: 0,
        vig: 10,
        str: 10,
        dex: 10,
        hp: 100,
        maxHp: 100,
        stamina: 100,
        maxStamina: 100,
        role: "WARRIOR",
      };

      // =========================================================
// LGICA DE JOYSTICK FLOTANTE (Din谩mico)
// =========================================================
let joystick = { x: 0, y: 0 };
let joystickTouchId = null; // Para saber qu茅 dedo es el del joystick
let joystickCenter = { x: 0, y: 0 };
const maxRadius = 40; // Rango m谩ximo de movimiento del c铆rculo interior

const joyContainer = document.getElementById("joystick-container");
const joyKnob = document.getElementById("joystick");

// Escuchamos los toques en TODA la pantalla
document.addEventListener("touchstart", function(e) {
  // Revisamos todos los dedos que acaban de tocar la pantalla
  for (let i = 0; i < e.changedTouches.length; i++) {
    const t = e.changedTouches[i];
    
    // Si el toque es en la mitad IZQUIERDA de la pantalla y no hay un joystick activo
    if (t.clientX < window.innerWidth / 2 && joystickTouchId === null) {
      joystickTouchId = t.identifier; // Guardamos el ID de este dedo en concreto
      joystickCenter = { x: t.clientX, y: t.clientY };
      
      // Teletransportamos el contenedor del joystick al dedo
      joyContainer.style.left = (t.clientX - joyContainer.offsetWidth / 2) + "px";
      joyContainer.style.top = (t.clientY - joyContainer.offsetHeight / 2) + "px";
      joyContainer.style.bottom = "auto"; // Anulamos el bottom del CSS original
      
      // Lo hacemos completamente visible
      joyContainer.style.opacity = "1";
      
      // Reiniciamos el centro visual
      joyKnob.style.transform = `translate(0px, 0px)`;
    }
  }
}, { passive: false });

document.addEventListener("touchmove", function(e) {
  for (let i = 0; i < e.changedTouches.length; i++) {
    const t = e.changedTouches[i];
    
    // Si este dedo es el que controla el joystick
    if (t.identifier === joystickTouchId) {
      let dx = t.clientX - joystickCenter.x;
      let dy = t.clientY - joystickCenter.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      // Limitar el movimiento al radio del contenedor
      if (distance > maxRadius) {
        dx = (dx / distance) * maxRadius;
        dy = (dy / distance) * maxRadius;
      }
      
      // Mover el c铆rculo interior
      joyKnob.style.transform = `translate(${dx}px, ${dy}px)`;
      
      // Actualizar variables para el juego
      joystick.x = dx / maxRadius;
      joystick.y = dy / maxRadius;
    }
  }
}, { passive: false });

document.addEventListener("touchend", function(e) {
  for (let i = 0; i < e.changedTouches.length; i++) {
    const t = e.changedTouches[i];
    
    // Si el dedo que se levanta es el del joystick
    if (t.identifier === joystickTouchId) {
      joystickTouchId = null; // Liberamos el joystick
      joystick.x = 0;
      joystick.y = 0;
      
      // Devolvemos el c铆rculo al centro
      joyKnob.style.transform = `translate(0px, 0px)`;
      
      // Bajamos la opacidad para que no moleste
      joyContainer.style.opacity = "0.3";
      
      // OPCIONAL: Devolverlo a su posici贸n original abajo a la izquierda 
      // joyContainer.style.left = "40px";
      // joyContainer.style.top = "auto";
      // joyContainer.style.bottom = "50px";
    }
  }
}, { passive: false });

// CANCELACIONES DE TOQUE (por si te llaman o minimizas el navegador)
document.addEventListener("touchcancel", function(e) {
  for (let i = 0; i < e.changedTouches.length; i++) {
    if (e.changedTouches[i].identifier === joystickTouchId) {
      joystickTouchId = null;
      joystick.x = 0;
      joystick.y = 0;
      joyKnob.style.transform = `translate(0px, 0px)`;
      joyContainer.style.opacity = "0.3";
    }
  }
});

      function toggleFullScreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch((e) => {});
        } else {
          document.exitFullscreen();
        }
      }

      function initScene() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        //scene.fog = new THREE.Fog(0x000000, 24, 33);
        const amb = new THREE.AmbientLight(0xffffff, 0.02); 
        scene.add(amb);
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          150 // Aumentamos el far plane para ver m谩s horizonte
        );
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Luces
        //const amb = new THREE.AmbientLight(0xffffff, 0.02); 
        //scene.add(amb);
        createWorld();
        setupInput();
      }

      function createWorld() {
        const groundGeo = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE);
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x1a3317,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        createObstacles();

        // Grid decorativo
        //const grid = new THREE.GridHelper(worldSize, 20, 0x333333, 0x222222);
        //grid.position.y = 0.01;
        //scene.add(grid);

        // Obst谩culos
      function createObstacles() {
        // Crear 100 obst谩culos aleatorios
        for (let i = 0; i < 100; i++) {
          const isTree = Math.random() > 0.3;
          const x = (Math.random() - 0.5) * (MAP_SIZE - 10);
          const z = (Math.random() - 0.5) * (MAP_SIZE - 10);
          
          let obstacle;
          if (isTree) {
            // rbol simple (Tronco caf茅 y copa verde)
            obstacle = new THREE.Group();
            const trunk = new THREE.Mesh(
              new THREE.CylinderGeometry(0.3, 0.3, 2),
              new THREE.MeshLambertMaterial({ color: 0x4b3621 })
            );
            trunk.position.y = 1;
            const leaves = new THREE.Mesh(
              new THREE.ConeGeometry(1.2, 3, 8),
              new THREE.MeshLambertMaterial({ color: 0x0b6623 })
            );
            leaves.position.y = 3;
            obstacle.add(trunk, leaves);
          } else {
            // Piedra
            obstacle = new THREE.Mesh(
              new THREE.DodecahedronGeometry(1),
              new THREE.MeshLambertMaterial({ color: 0x808080 })
            );
            obstacle.position.y = 0.5;
            obstacle.scale.set(Math.random() + 0.5, 0.5, Math.random() + 0.5);
          }

          obstacle.position.set(x, 0, z);
          obstacle.userData = { isObstacle: true, radius: 1.2 };
          
          scene.add(obstacle);
          
          // Guardar para colisiones (radio aproximado de 1.2 unidades)
         obstacles.push({ position: obstacle.position, radius: 1.2 });
        }
      }

        for (let i = 0; i < 8; i++)
          spawnCamp(
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100,
            i
          );
      }

      function spawnCamp(x, z, id) {
        const group = new THREE.Group();
        const fireBase = new THREE.Mesh(
          new THREE.CylinderGeometry(1.5, 2, 0.5, 8),
          new THREE.MeshStandardMaterial({ 
            color: 0x333333, 
            transparent: true, 
            opacity: 0 // Empezamos invisible
          })
        );
        group.add(fireBase);
        const light = new THREE.PointLight(0xff4400, 2, 10);
        light.position.y = 1;
        group.add(light);

        // Part铆cula de fuego simple
        const flame = new THREE.Mesh(
          new THREE.SphereGeometry(0.5, 8, 8),
          new THREE.MeshBasicMaterial({ 
            color: 0xffaa00, 
            transparent: true, 
            opacity: 0 
          })
        );
        flame.position.y = 0.5;
        group.add(flame);

        group.position.set(x, 0.25, z);
        group.userData = { isCamp: true, id: id, used: false };
        scene.add(group);
      }

      function createCharacter(role, isEnemy = false) {
        const group = new THREE.Group();
        const col = isEnemy
          ? Math.random() > 0.5
            ? ROLES.WARRIOR.color
            : ROLES.SCOUT.color
          : ROLES[role].color;

        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8),
          new THREE.MeshStandardMaterial({ color: col })
        );
        body.position.y = 0.75;
        group.add(body);

        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.35, 8, 8),
          new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        head.position.set(0, 1.6, 0.2);
        group.add(head);

        // Barra de vida para enemigos
       if (isEnemy) {
          const hpContainer = new THREE.Group();
          
          // Fondo Negro (Borde)
          const bgWidth = 1.2;
          const bgHeight = 0.25;
          const hpBg = new THREE.Mesh(
            new THREE.PlaneGeometry(bgWidth, bgHeight),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
          );
          hpContainer.add(hpBg);

          // Barra Roja (Frente)
          const fgWidth = 1.1; 
          const fgHeight = 0.15;
          const hpGeometry = new THREE.PlaneGeometry(fgWidth, fgHeight);
          hpGeometry.translate(fgWidth / 2, 0, 0); 

          const hpFg = new THREE.Mesh(
            hpGeometry,
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
          );
          hpFg.position.set(-fgWidth / 2, 0, 0.01); 
          hpContainer.add(hpFg);

          // Guardar referencias en el enemigo
          group.userData.hpBar = hpFg;
          group.userData.hpContainer = hpContainer; 

          // IMPORTANTE: Se a帽ade a la escena, NO al enemigo
          scene.add(hpContainer);
        }

        group.position.set(
          (Math.random() - 0.5) * 80,
          0,
          (Math.random() - 0.5) * 80
        );

        if (isEnemy) {
  const lvl = 1 + Math.floor(Math.random() * 3);

  group.userData.isEnemy = true;
  group.userData.hp = 80 + lvl * 20;
  group.userData.maxHp = 80 + lvl * 20;
  group.userData.xpReward = 50 * lvl;
  group.userData.targetPos = new THREE.Vector3(
    (Math.random() - 0.5) * 100,
    0,
    (Math.random() - 0.5) * 100
  );
}


        scene.add(group);
        return group;
      }

      function setupInput() {
        // Joystick
        const container = document.getElementById("joystick-container");
        const knob = document.getElementById("joystick-knob");

        const handleStart = (e) => {
          joystick.active = true;
          const touch = e.touches ? e.touches[0] : e;
          const rect = container.getBoundingClientRect();
          joystick.startX = rect.left + rect.width / 2;
          joystick.startY = rect.top + rect.height / 2;
        };

        const handleMove = (e) => {
          if (!joystick.active) return;
          const touch = e.touches ? e.touches[0] : e;
          const dx = touch.clientX - joystick.startX;
          const dy = touch.clientY - joystick.startY;
          const dist = Math.min(Math.sqrt(dx * dx + dy * dy), 50);
          const angle = Math.atan2(dy, dx);

          joystick.x = (Math.cos(angle) * dist) / 50;
          joystick.y = (Math.sin(angle) * dist) / 50;

          knob.style.transform = `translate(${joystick.x * 50}px, ${
            joystick.y * 50
          }px)`;
        };

        const handleEnd = () => {
          joystick.active = false;
          joystick.x = 0;
          joystick.y = 0;
          knob.style.transform = "translate(0,0)";
        };

        container.addEventListener("touchstart", handleStart);
        window.addEventListener("touchmove", handleMove);
        window.addEventListener("touchend", handleEnd);

        // Teclado (PC)
        window.addEventListener("keydown", (e) => {
          keys[e.code] = true;
          if (e.code === "Space") triggerDash();
          if (e.code === "Enter") triggerAttack();
        });
        window.addEventListener("keyup", (e) => (keys[e.code] = false));

        // Mouse Click Attack
        window.addEventListener("mousedown", (e) => {
          // Solo si no estamos tocando UI
          if (e.target.tagName !== "BUTTON") triggerAttack();
        });
      }
      function spawnArmedEnemy() {
        // 1. Crear el cuerpo base
        const enemy = createCharacter("WARRIOR", true);
        
        // 2. Crear la espada del enemigo
        const enemySwordPivot = new THREE.Group();
        enemySwordPivot.position.set(0.7, 0.6, -0.2); 
        
        const hiltGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.5, 8);
        const hiltMat = new THREE.MeshBasicMaterial({ color: 0x444444 });
        const enHilt = new THREE.Mesh(hiltGeo, hiltMat);
        enHilt.position.y = 0.2; 
        enemySwordPivot.add(enHilt);
        
        const bladeGeo = new THREE.BoxGeometry(0.25, 2.2, 0.06);
        const bladeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 });
        const enBlade = new THREE.Mesh(bladeGeo, bladeMat); 
        enBlade.position.y = 1.6; 
        enemySwordPivot.userData.bladeMesh = enBlade; 
        enemySwordPivot.add(enBlade);
        
        enemySwordPivot.rotation.set(Math.PI / 1.8, 0, -Math.PI / 6);
        enemy.add(enemySwordPivot);
        
        // 3. Variables de control de combate del enemigo
        enemy.userData.swordPivot = enemySwordPivot;
        enemy.userData.isAttacking = false;
        enemy.userData.attackProgress = 0;
        enemy.userData.damageDealtThisSwing = false;
        
        // 4. A帽adirlo a la lista de enemigos activos
        enemies.push(enemy);
      }

      function startGame(role) {
        document.getElementById("lobby").classList.add("hidden");
        document.getElementById("hud").classList.remove("hidden");
        document.getElementById("skill-btn").innerText = ROLES[role].skillName;

        player = createCharacter(role);
        player.userData.radius = 0.5;
        playerStats.role = role;
        
        const playerLight = new THREE.PointLight(0xffffff, 6, 16, 1.5);
        playerLight.position.set(0, 4, 0); 
        player.add(playerLight);

        // --- CREAR Y EQUIPAR LA ESPADA (JUGADOR) ---
        swordPivot = new THREE.Group();
        swordPivot.position.set(0.7, 0.6, -0.2); 

        const hiltGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.5, 8);
        const hiltMat = new THREE.MeshBasicMaterial({ color: 0x444444 });
        const hilt = new THREE.Mesh(hiltGeo, hiltMat);
        hilt.position.y = 0.2; 
        swordPivot.add(hilt);

        const bladeGeo = new THREE.BoxGeometry(0.25, 2.2, 0.06);
        const bladeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 });
        const blade = new THREE.Mesh(bladeGeo, bladeMat);
        blade.position.y = 1.6; 
        swordPivot.userData.bladeMesh = blade; 
        swordPivot.add(blade);

        swordPivot.rotation.x = Math.PI / 1.8; 
        swordPivot.rotation.z = -Math.PI / 6; 
        player.add(swordPivot);
        // ---------------------------------

        isGameRunning = true;

        // --- GENERACIN DE ENEMIGOS ARMADOS ---
        for (let i = 0; i < 9; i++) {
          spawnArmedEnemy();
        }
        
        updateHUD();
        animate();
      }

      // Acciones
      function triggerSkill() {
        if (!isGameRunning) return;

        // Restricci贸n de Nivel
        if (playerStats.lvl < 2) {
          showFloatingText("隆Necesitas Nivel 2!", player.position, "red");
          return;

          // Boost
          const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(
            player.quaternion
          );
          player.position.addScaledVector(dir, 5); // Teleport corto
        }
      }

      function triggerDash() {
        if (!isGameRunning) return;
        
        // --- Restricci贸n de Nivel ---
        if (playerStats.lvl < 2) {
          showFloatingText("隆Necesitas Nivel 2!", player.position, "red");
          return;
        }

        if (isDashing) return; // No hacer dash si ya est谩s haciendo uno
        
        // Coste de stamina
        if (playerStats.stamina < 20) return;
        playerStats.stamina -= 20;

        isDashing = true;
        dashProgress = 0;

        // Hacia d贸nde mira el jugador actualmente (por el joystick)
        const targetRot = player.userData.baseRotation || player.rotation.y;
        
        // Calculamos la direcci贸n del dash
        dashDir.set(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), targetRot).normalize();

        // Efecto visual en el bot贸n (隆Corregido el ID a "skill-btn"!)
        const btn = document.getElementById("skill-btn");
        if (btn) {
          btn.classList.add("btn-active");
          setTimeout(() => btn.classList.remove("btn-active"), 100);
        }
      }

      function triggerAttack() {
        if (!isGameRunning) return;
        // Si ya estamos atacando, no hacemos nada (evita spamear el bot贸n)
        if (isAttacking) return;

        // Animaci贸n visual del bot贸n
        const btn = document.getElementById("attack-btn");
        btn.classList.add("btn-active");
        setTimeout(() => btn.classList.remove("btn-active"), 100);

        if (playerStats.stamina < 10) return;
        playerStats.stamina -= 10;

        // --- INICIAR SECUENCIA DE ATAQUE CON LA ESPADA ---
        isAttacking = true;
        attackProgress = 0;
        damageDealtThisSwing = false;

        player.userData.baseRotation = player.rotation.y;

        // Visual Attack (Onda en el suelo - la mantenemos)
        /*const wave = new THREE.Mesh(
          new THREE.RingGeometry(0.5, 2.5, 3),
          new THREE.MeshBasicMaterial({
            color: 0xffaa00,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
          })
        );
        wave.rotation.x = -Math.PI / 2;
        wave.position.copy(player.position);
        wave.position.y = 0.5;
        wave.quaternion.copy(player.quaternion);
        wave.rotateX(-Math.PI / 2);

        scene.add(wave);
        setTimeout(() => scene.remove(wave), 150);*/
      }

      function killEnemy(enemy, index) {
        // Eliminar visuales del enemigo actual
        scene.remove(enemy);
        if (enemy.userData.hpContainer) {
          scene.remove(enemy.userData.hpContainer);
        }
        
        // Quitarlo del array de enemigos activos
        enemies.splice(index, 1);

        // Subir experiencia del jugador (o lo que tengas en tu c贸digo)
        playerStats.exp += 20;
        // ... (tu l贸gica de subir nivel) ...

        // --- LGICA DE RESPAWN ---
        // Si en el futuro NO quieres respawn para el multijugador, 
        // simplemente borras o comentas este setTimeout entero.
        setTimeout(() => {
          spawnArmedEnemy(); // <-- 隆AQU EST LA MAGIA! Genera un enemigo con espada y l贸gica de combate correcta
        }, 5000); // Reaparece a los 5 segundos
      }

      function showFloatingText(text, pos, color) {
        const div = document.createElement("div");
        div.innerText = text;
        div.className = color === "gold" ? "xp-text" : "damage-text";
        div.style.color = color;

        // Proyectar posici贸n 3D a 2D
        const vec = pos.clone();
        vec.y += 2;
        vec.project(camera);
        const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-(vec.y * 0.5) + 0.5) * window.innerHeight;

        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 1500);
      }

      function toggleStats() {
        const panel = document.getElementById("attr-panel");
        panel.classList.toggle("hidden");
      }

      function upgradeStat(stat) {
        if (playerStats.xp >= 100) {
          playerStats.xp -= 100;
          playerStats[stat]++;
          if (stat === "vig") {
            playerStats.maxHp += 20;
            playerStats.hp = playerStats.maxHp;
          }
          updateHUD();
        }
      }

      function acceptQuest() {
        if (!currentCamp) return;
        currentCamp.userData.used = true;
        currentCamp.children[1].intensity = 0; // Apagar luz

        playerStats.xp += 150;
        playerStats.lvl++;

        const isWarrior = playerStats.role === "WARRIOR";
        if (isWarrior) playerStats.str += 5;
        else playerStats.dex += 5;

        showFloatingText("隆PODER AUMENTADO!", player.position, "yellow");

        closeQuest();
        updateHUD();

        // Bloquear otro campamento
        const others = scene.children.filter(
          (c) => c.userData.isCamp && !c.userData.used
        );
        if (others.length > 0) {
          const blocked = others[Math.floor(Math.random() * others.length)];
          blocked.userData.used = true;
          blocked.children[0].material.color.setHex(0x333333); // Gris visual
        }
      }

      function closeQuest() {
        document.getElementById("quest-notifier").classList.add("hidden");
        currentCamp = null;
      }

      function updateHUD() {
        const hpPct = (playerStats.hp / playerStats.maxHp) * 100;
        document.getElementById("hp-bar").style.width = `${hpPct}%`;
        document.getElementById("hp-text").innerText = `${Math.floor(
          playerStats.hp
        )}/${playerStats.maxHp}`;
        document.getElementById("stamina-bar").style.width = `${
          (playerStats.stamina / playerStats.maxStamina) * 100
        }%`;
        document.getElementById("xp-val").innerText = playerStats.xp;
        document.getElementById("lvl-val").innerText = playerStats.lvl;

        document.getElementById("stat-vig").innerText = playerStats.vig;
        document.getElementById("stat-str").innerText = playerStats.str;
        document.getElementById("stat-dex").innerText = playerStats.dex;

        // Skill Unlock Visual
        const skillBtn = document.getElementById("skill-btn");
        const lockIcon = document.getElementById("lock-icon");
        if (playerStats.lvl >= 2) {
          skillBtn.classList.remove("btn-disabled");
          if (lockIcon) lockIcon.style.display = "none";
        }
      }

      function checkCollisions(newPos) {
        // Colisi贸n con Obst谩culos
        for (let obj of scene.children) {
          if (obj.userData.isObstacle) {
            const dist = newPos.distanceTo(
              new THREE.Vector3(obj.position.x, 0, obj.position.z)
            );
            // Radio jugador (0.5) + Radio objeto
            if (dist < 0.5 + obj.userData.radius) return true;
          }
        }
        // Colisi贸n con Enemigos (Cuerpo a cuerpo)
        for (let en of enemies) {
          const dist = newPos.distanceTo(en.position);
          if (dist < 1.0) return true; // Bloqueo f铆sico
        }
        return false;
      }

      function animate() {
        if (!isGameRunning) return;
        requestAnimationFrame(animate);

        let moveX = joystick.x;
        let moveY = joystick.y;

        if (keys["KeyW"] || keys["ArrowUp"]) moveY = -1;
        if (keys["KeyS"] || keys["ArrowDown"]) moveY = 1;
        if (keys["KeyA"] || keys["ArrowLeft"]) moveX = -1;
        if (keys["KeyD"] || keys["ArrowRight"]) moveX = 1;

        let isMoving = (moveX !== 0 || moveY !== 0);
        
        let baseTargetRotation = player.userData.baseRotation !== undefined ? player.userData.baseRotation : player.rotation.y;

        // --- MOVIMIENTO JUGADOR Y DASH ---
        if (isDashing) {
          player.userData.isInvincible = true;

          // <-- VELOCIDAD DE DASH REDUCIDA
          dashProgress += 0.05; 
          const currentDashSpeed = 0.5 * (1 - dashProgress); 

          const nextPos = player.position.clone().addScaledVector(dashDir, currentDashSpeed);
          const limit = MAP_SIZE / 2 - 1; 
          nextPos.x = THREE.MathUtils.clamp(nextPos.x, -limit, limit);
          nextPos.z = THREE.MathUtils.clamp(nextPos.z, -limit, limit);

          if (!checkCollisions(nextPos)) {
            player.position.copy(nextPos); 
          }

          player.rotation.x = (Math.PI / 8) * Math.sin(dashProgress * Math.PI);

          if (Math.random() > 0.3) {
            const ghost = new THREE.Mesh(player.geometry, new THREE.MeshBasicMaterial({ 
              color: 0x5555ff, transparent: true, opacity: 0.4 * (1 - dashProgress) 
            }));
            ghost.position.copy(player.position);
            ghost.rotation.copy(player.rotation);
            scene.add(ghost);
            setTimeout(() => scene.remove(ghost), 150);
          }

          if (dashProgress >= 1.0) {
            isDashing = false;
            player.rotation.x = 0; 
            player.userData.isInvincible = false;
          }

        } else if (isMoving) {
          // <-- VELOCIDAD DE MOVIMIENTO DEL JUGADOR REDUCIDA
          const speed = ROLES[playerStats.role].speed * (1 + playerStats.dex / 50) * 0.8;
          const moveVec = new THREE.Vector3(moveX, 0, moveY).normalize().multiplyScalar(speed);
          const nextPos = player.position.clone().add(moveVec);
          const limit = MAP_SIZE / 2 - 1; 
          nextPos.x = THREE.MathUtils.clamp(nextPos.x, -limit, limit);
          nextPos.z = THREE.MathUtils.clamp(nextPos.z, -limit, limit);

          if (!checkCollisions(nextPos)) {
            player.position.copy(nextPos); 
          }
          
          baseTargetRotation = Math.atan2(moveX, moveY);
          player.userData.baseRotation = baseTargetRotation; 

          if (Math.random() > 0.95) {
            const footprint = new THREE.Mesh(new THREE.CircleGeometry(0.15, 6), new THREE.MeshBasicMaterial({ color: 0x222222, transparent: true, opacity: 0.5 }));
            footprint.rotation.x = -Math.PI / 2;
            footprint.position.set(player.position.x, 0.02, player.position.z);
            scene.add(footprint);
            setTimeout(() => scene.remove(footprint), 5000);
          }
        }

        camera.position.set(player.position.x, player.position.y + 20, player.position.z + 15);
        camera.lookAt(player.position);

        if (shakeTime > 0) {
          const intensity = shakeTime * 3.0; 
          camera.position.x += (Math.random() - 0.5) * intensity;
          camera.position.y += (Math.random() - 0.5) * intensity;
          camera.position.z += (Math.random() - 0.5) * intensity;
          shakeTime -= 0.02; 
        }

        if (playerStats.stamina < 100) playerStats.stamina += 0.3;

        // --- ANIMACIN ESPADA JUGADOR ---
        let bodyTwist = 0; 
        if (isAttacking && swordPivot) {
          // <-- VELOCIDAD DE ATAQUE DEL JUGADOR REDUCIDA
          const currentAttackSpeed = 0.07; 
          attackProgress += currentAttackSpeed;
          const attackDir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), baseTargetRotation).normalize();

          if (attackProgress <= 0.2) {
            const p = attackProgress / 0.2; 
            bodyTwist = (Math.PI / 6) * p; 
            swordPivot.position.x = 0.7 + 0.3 * p; 
            swordPivot.position.z = -0.2 - 0.4 * p; 
            swordPivot.rotation.y = (Math.PI / 4) * p; 
            swordPivot.rotation.x = Math.PI / 1.8 - (Math.PI / 6) * p;
          } else if (attackProgress <= 0.5) {
            const p = (attackProgress - 0.2) / 0.3; 
            const easeOut = Math.sin(p * Math.PI / 2); 
            bodyTwist = (Math.PI / 6) - (Math.PI / 2.5) * easeOut;

            if (p < 0.6 && !isMoving && !isDashing) { 
              // <-- IMPULSO HACIA ADELANTE REDUCIDO
              const lungeSpeed = 0.1;
              const nextLungePos = player.position.clone().addScaledVector(attackDir, lungeSpeed);
              if (!checkCollisions(nextLungePos)) player.position.copy(nextLungePos);
            }

            swordPivot.position.x = 1.0 - 2.0 * easeOut; 
            swordPivot.position.z = -0.6 + 0.4 * Math.sin(easeOut * Math.PI); 
            swordPivot.rotation.y = (Math.PI / 4) - (Math.PI * 1.5) * easeOut;
            swordPivot.rotation.x = Math.PI / 2; 

            if (swordPivot.userData.bladeMesh) swordPivot.userData.bladeMesh.material.emissive.setHex(0xaaaaaa);

            if (p > 0.4 && !damageDealtThisSwing) {
              damageDealtThisSwing = true;
              const attackRange = 2.8; 
              const attackAngle = Math.PI / 1.2; 
              let hitSomething = false; 

              enemies.forEach((enemy, index) => {
                const dist = player.position.distanceTo(enemy.position);
                if (dist < attackRange) {
                  const enemyDir = new THREE.Vector3().subVectors(enemy.position, player.position).normalize();
                  const angle = attackDir.angleTo(enemyDir);

                  if (angle < attackAngle) {
                    hitSomething = true; 
                    const dmg = playerStats.str + ROLES[playerStats.role].baseDmg;
                    enemy.userData.hp -= dmg;
                    showFloatingText(`-${dmg}`, enemy.position, "red");
                    
                    const push = enemyDir.multiplyScalar(2.0); 
                    enemy.position.add(push);
                    
                    const hpPercent = Math.max(0, enemy.userData.hp / enemy.userData.maxHp);
                    enemy.userData.hpBar.scale.x = hpPercent;
                    if (enemy.userData.hp <= 0) killEnemy(enemy, index);
                  }
                }
              });
              if (hitSomething) shakeTime = 0.2; 
            }
          } else if (attackProgress <= 1.0) {
            const p = (attackProgress - 0.5) / 0.5; 
            const easeIn = 1 - Math.cos(p * Math.PI / 2); 
            bodyTwist = (-Math.PI / 4.1) * (1 - easeIn);
            swordPivot.position.x = -1.0 + 1.7 * easeIn; 
            swordPivot.position.z = -0.6 + 0.4 * easeIn; 
            swordPivot.rotation.y = (-Math.PI * 1.25) * (1 - easeIn);
            swordPivot.rotation.x = Math.PI / 2 + (Math.PI / 1.8 - Math.PI / 2) * easeIn;
            if (swordPivot.userData.bladeMesh) swordPivot.userData.bladeMesh.material.emissive.setHex(0x000000);
          } else {
            isAttacking = false;
            bodyTwist = 0;
            swordPivot.position.set(0.7, 0.6, -0.2);
            swordPivot.rotation.set(Math.PI / 1.8, 0, -Math.PI / 6);
            if (swordPivot.userData.bladeMesh) swordPivot.userData.bladeMesh.material.emissive.setHex(0x000000);
          }
        }
        player.rotation.y = baseTargetRotation + bodyTwist;


        // ==================================================================
        // --- LGICA DE ENEMIGOS: IA Y COMBATE ---
        // ==================================================================
        enemies.forEach((en) => {
          const oldEnPos = en.position.clone();
          const dist = en.position.distanceTo(player.position);
          let enemyBodyTwist = 0; 

          if (en.userData.isAttacking) {
            // <-- VELOCIDAD DE ATAQUE DE ENEMIGOS REDUCIDA
            en.userData.attackProgress += 0.03; 
            const pTotal = en.userData.attackProgress;
            const pivot = en.userData.swordPivot;
            
            const baseRot = en.userData.baseRotation !== undefined ? en.userData.baseRotation : en.rotation.y;
            const enemyAttackDir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), baseRot).normalize();

            if (pTotal <= 0.3) {
              const p = pTotal / 0.3;
              enemyBodyTwist = (Math.PI / 6) * p; 
              pivot.position.x = 0.7 + 0.3 * p;
              pivot.position.z = -0.2 - 0.4 * p;
              pivot.rotation.y = (Math.PI / 4) * p;
              pivot.rotation.x = Math.PI / 1.8 - (Math.PI / 6) * p;
            } else if (pTotal <= 0.6) {
              const p = (pTotal - 0.3) / 0.3;
              const easeOut = Math.sin(p * Math.PI / 2);
              enemyBodyTwist = (Math.PI / 6) - (Math.PI / 2.5) * easeOut;

              if (p < 0.6) { 
                  // <-- IMPULSO DEL ENEMIGO AL ATACAR REDUCIDO
                  const lungeSpeed = 0.1;
                  const nextLungePos = en.position.clone().addScaledVector(enemyAttackDir, lungeSpeed);
                  if (nextLungePos.distanceTo(player.position) > 0.8) {
                      en.position.copy(nextLungePos);
                  }
              }

              pivot.position.x = 1.0 - 2.0 * easeOut;
              pivot.position.z = -0.6 + 0.4 * Math.sin(easeOut * Math.PI);
              pivot.rotation.y = (Math.PI / 4) - (Math.PI * 1.5) * easeOut;
              pivot.rotation.x = Math.PI / 2;
              
              if (pivot.userData.bladeMesh) pivot.userData.bladeMesh.material.emissive.setHex(0xaa0000); 

              if (p > 0.4 && !en.userData.damageDealtThisSwing) {
                en.userData.damageDealtThisSwing = true;
                
                if (dist < 3.2 && !player.userData.isInvincible) { 
                  const dirToPlayer = new THREE.Vector3().subVectors(player.position, en.position).normalize();
                  
                  if (enemyAttackDir.angleTo(dirToPlayer) < Math.PI / 1.2) {
                    const dmg = 25;
                    playerStats.hp -= dmg;
                    showFloatingText(`-${dmg}`, player.position, "red");
                    shakeTime = 0.4;
                    
                    if (playerStats.hp <= 0) {
                      playerStats.hp = 0;
                      isGameRunning = false;
                      document.getElementById("game-over-screen").classList.remove("hidden");
                    }
                  }
                } else if (dist < 3.2 && player.userData.isInvincible) {
                  showFloatingText("ESQUIVE", player.position, "white");
                }
              }
            } else if (pTotal <= 1.0) {
              const p = (pTotal - 0.6) / 0.4;
              const easeIn = 1 - Math.cos(p * Math.PI / 2);
              enemyBodyTwist = (-Math.PI / 4.1) * (1 - easeIn);
              
              pivot.position.x = -1.0 + 1.7 * easeIn;
              pivot.position.z = -0.6 + 0.4 * easeIn;
              pivot.rotation.y = (-Math.PI * 1.25) * (1 - easeIn);
              pivot.rotation.x = Math.PI / 2 + (Math.PI / 1.8 - Math.PI / 2) * easeIn;
              
              if (pivot.userData.bladeMesh) pivot.userData.bladeMesh.material.emissive.setHex(0x000000);
            } else {
              en.userData.isAttacking = false;
              enemyBodyTwist = 0;
              pivot.position.set(0.7, 0.6, -0.2);
              pivot.rotation.set(Math.PI / 1.8, 0, -Math.PI / 6);
              if (pivot.userData.bladeMesh) pivot.userData.bladeMesh.material.emissive.setHex(0x000000);
            }

            en.rotation.y = baseRot + enemyBodyTwist;

          } 
          else if (dist < 15) {
            if (dist < 2.5) {
              en.userData.isAttacking = true;
              en.userData.attackProgress = 0;
              en.userData.damageDealtThisSwing = false;
              en.lookAt(player.position); 
              en.userData.baseRotation = en.rotation.y;
            } else {
              const dir = new THREE.Vector3().subVectors(player.position, en.position).normalize();
              // <-- VELOCIDAD DE PERSECUCIN ENEMIGA REDUCIDA
              const nextPos = en.position.clone().addScaledVector(dir, 0.025); 
              if (nextPos.distanceTo(player.position) > 1.0) {
                en.position.copy(nextPos);
              }
              en.lookAt(player.position);
            }
          } else {
            const dir = new THREE.Vector3().subVectors(en.userData.targetPos, en.position).normalize();
            // <-- VELOCIDAD DE PATRULLAJE ENEMIGA REDUCIDA
            en.position.addScaledVector(dir, 0.015);
            if (en.position.distanceTo(en.userData.targetPos) < 2) {
              en.userData.targetPos.set((Math.random() - 0.5) * 100, 0, (Math.random() - 0.5) * 100);
            }
          }
          
          obstacles.forEach(obj => {
            if (en.position.distanceTo(obj.position) < obj.radius) {
              en.position.copy(oldEnPos);
            }
          });
          if (en.userData.hpContainer) {
            en.userData.hpContainer.position.copy(en.position);
            en.userData.hpContainer.position.y += 2.5; 
            en.userData.hpContainer.quaternion.copy(camera.quaternion);
          }
        });

        // --- SISTEMAS DE ENTORNO ---
        scene.children.forEach((c) => {
          if (c.userData.isCamp && !c.userData.used && !currentCamp) {
            if (player.position.distanceTo(c.position) < 3) {
              currentCamp = c;
              document.getElementById("quest-notifier").classList.remove("hidden");
              document.getElementById("quest-title").innerText = "CAMPAMENTO DE PODER";
              document.getElementById("quest-desc").innerText = "Absorber el poder de este lugar aumentar谩 tu nivel y estad铆sticas dr谩sticamente.";
            }
          }
        });

        const luzAlcance = 16;      
        const rangoInstinto = 25;   
        const umbralVision = 0.5;   
        const playerDir = new THREE.Vector3();
        player.getWorldDirection(playerDir);
        const rangoCargaTecnica = 40; 
        const rangoInicioVisible = 25; 
        const rangoBrilloMaximo = 15; 
        
        scene.children.forEach(obj => {
          if (obj.userData.isObstacle) {
            const dist = obj.position.distanceTo(player.position);
            obj.visible = dist < rangoInicioVisible;
          }
          if (obj.userData.isCamp) {
            const dist = obj.position.distanceTo(player.position);
            const base = obj.children[0]; 
            const campLight = obj.children[1]; 
            const flame = obj.children[2];
            obj.visible = dist < rangoCargaTecnica; 
            let porcentaje = 0;
            if (dist < rangoInicioVisible) {
                porcentaje = 1 - ((dist - rangoBrilloMaximo) / (rangoInicioVisible - rangoBrilloMaximo));
                porcentaje = Math.max(0, Math.min(1, porcentaje)); 
            }
            if (!obj.userData.used && campLight) {
              campLight.intensity = porcentaje * 2;
              campLight.distance = porcentaje * 15; 
            }
            if (flame) {
              flame.scale.setScalar(Math.max(0.001, porcentaje));
              if (flame.material) {
                flame.material.transparent = true;
                flame.material.opacity = porcentaje;
              }
            }
            if (base && base.traverse) {
              base.traverse(child => {
                if (child.isMesh && child.material) {
                  child.material.transparent = true;
                  child.material.opacity = porcentaje;
                }
              });
            }
          }
        });

        enemies.forEach((en) => {
          const dist = en.position.distanceTo(player.position);
          const dirToEnemy = new THREE.Vector3().subVectors(en.position, player.position).normalize();
          const dot = playerDir.dot(dirToEnemy);
          const estaEnFrente = dot > umbralVision;
          en.visible = dist < rangoInstinto; 
          if (en.userData.hpContainer) {
            const puedeDetectarHP = (dist < luzAlcance) || (dist < rangoInstinto && estaEnFrente);
            en.userData.hpContainer.visible = puedeDetectarHP;
          }
        });

        renderer.render(scene, camera);
        updateHUD();
      }

      window.onload = initScene;
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      // =========================================================
// SOLUCIN MULTITOUCH PARA BOTONES (Ataque y Dash)
// =========================================================
const btnAttack = document.getElementById("attack-btn");
const btnDash = document.getElementById("skill-btn");

function aislarBotonTactil(elemento, accion) {
  if (!elemento) return;

  // CUANDO PULSAS EL BOTN (M贸vil)
  elemento.addEventListener("touchstart", function(e) {
    e.preventDefault();   // Evita comportamientos raros del navegador
    e.stopPropagation();  // EVITA que el toque llegue al joystick
    accion();             // Ejecuta tu ataque o dash
  }, { passive: false }); // 'passive: false' es obligatorio para que preventDefault funcione en m贸viles hoy en d铆a

  // CUANDO SUELTAS EL BOTN (M贸vil)
  elemento.addEventListener("touchend", function(e) {
    e.preventDefault();
    e.stopPropagation();  // EVITA que al soltar el bot贸n, el joystick se reinicie
  }, { passive: false });

  // PARA QUE SIGA FUNCIONANDO EN PC (Rat贸n)
  elemento.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    accion();
  });

  elemento.addEventListener("mouseup", function(e) {
    e.preventDefault();
    e.stopPropagation();
  });
}

// Vinculamos los botones a sus funciones
aislarBotonTactil(btnAttack, triggerAttack);
aislarBotonTactil(btnDash, triggerDash);
    </script>
  </body>
</html>

<!--- ahora la barra del enemigo se resta de derecha a izquierda correctamente.