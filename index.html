<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Juego 3D RPG</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #1a1a2e;
        font-family: Arial, sans-serif;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      #ui-layer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
      }

      .hp-container {
        position: fixed;
        width: 60px;
        height: 8px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #fff;
        border-radius: 4px;
        overflow: hidden;
        transform: translate(-50%, -50%);
      }

      .hp-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff3333, #ffaa33);
        width: 100%;
        transition: width 0.2s ease;
      }

      #hud {
        position: fixed;
        top: 20px;
        left: 20px;
        color: #fff;
        font-size: 16px;
        z-index: 20;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      }

      .hud-stat {
        margin: 8px 0;
      }

      .bar-bg {
        width: 200px;
        height: 20px;
        background: rgba(0,0,0,0.5);
        border: 1px solid #fff;
        margin-top: 4px;
        overflow: hidden;
      }

      .bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ff00, #ffff00);
        transition: width 0.2s ease;
      }

      .xp-bar .bar-fill {
        background: linear-gradient(90deg, #0088ff, #00ffff);
      }
    </style>
  </head>
  <body>
    <div id="ui-layer"></div>
    <div id="hud">
      <div class="hud-stat">Level: <span id="level">1</span></div>
      <div class="hud-stat">XP: <span id="xp">0</span>/<span id="xp-max">100</span></div>
      <div class="xp-bar">
        <div class="bar-bg">
          <div class="bar-fill" id="xp-fill" style="width: 0%"></div>
        </div>
      </div>
      <div class="hud-stat" style="margin-top: 15px;">HP: <span id="hp">100</span>/<span id="hp-max">100</span></div>
      <div class="hp-bar">
        <div class="bar-bg">
          <div class="bar-fill" id="hp-fill" style="width: 100%; background: linear-gradient(90deg, #ff0000, #ffaa00);"></div>
        </div>
      </div>
      <div class="hud-stat" style="margin-top: 15px;">DMG: <span id="dmg">10</span></div>
      <div style="font-size: 12px; margin-top: 20px; color: #aaa;">
        <div>W/A/S/D - Mover</div>
        <div>Click - Atacar</div>
        <div>ESPACIO - Dash</div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // CONFIGURACIÓN
      const CONFIG = {
        mapSize: 100,
        enemyCount: 15,
        respawnTime: 3000,
      };

      // CANVAS Y RENDERER
      const canvas = document.createElement('canvas');
      document.body.appendChild(canvas);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMapSoft = true;

      // ESCENA
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);
      scene.fog = new THREE.Fog(0x1a1a2e, 200, 500);

      // CÁMARA
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      // LUZ
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.far = 200;
      directionalLight.shadow.camera.left = -100;
      directionalLight.shadow.camera.right = 100;
      directionalLight.shadow.camera.top = 100;
      directionalLight.shadow.camera.bottom = -100;
      scene.add(directionalLight);

      // SUELO
      const groundGeo = new THREE.PlaneGeometry(CONFIG.mapSize, CONFIG.mapSize);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x2d5016,
        roughness: 0.8,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // STATS
      const stats = {
        level: 1,
        xp: 0,
        xpMax: 100,
        hp: 100,
        maxHp: 100,
        dmg: 10,
      };

      // JUGADOR
      const player = createUnit(true, 'WARRIOR', new THREE.Vector3(0, 0, 0));
      player.userData = {
        id: 'player',
        isPlayer: true,
        speed: 0.15,
        lastAttack: 0,
        skillCooldown: { dash: 0, strike: 0 },
      };

      // ENEMIGOS
      const enemies = [];

      function createUnit(isPlayer, role, pos) {
        const group = new THREE.Group();
        const color = isPlayer
          ? role === 'WARRIOR'
            ? 0xff3333
            : 0x33ff33
          : 0xaaaaaa;

        // Modelo simple
        const bodyGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
        const bodyMat = new THREE.MeshStandardMaterial({ color: color });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.75;
        body.castShadow = true;
        group.add(body);

        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.4, 0.4),
          new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        head.position.set(0, 1.6, 0.3);
        group.add(head);

        // Crear barra de vida en HTML (para enemigos)
        let hpBarElement = null;
        if (!isPlayer) {
          hpBarElement = document.createElement('div');
          hpBarElement.className = 'hp-container';
          hpBarElement.style.display = 'none';

          const fill = document.createElement('div');
          fill.className = 'hp-fill';
          hpBarElement.appendChild(fill);
          document.getElementById('ui-layer').appendChild(hpBarElement);

          // Randomizar stats enemigos
          const lvl = Math.floor(Math.random() * 3) + 1;
          group.userData = {
            id: Math.random(),
            isEnemy: true,
            hp: 50 * lvl,
            maxHp: 50 * lvl,
            dmg: 5 * lvl,
            lvl: lvl,
            speed: 0.08 + Math.random() * 0.04,
            lastAttack: 0,
            target: null,
            hpBarElement: hpBarElement,
          };

          // Color por nivel
          if (lvl > 2) bodyMat.color.setHex(0x5500aa);
        }

        group.position.copy(pos);
        group.castShadow = true;
        scene.add(group);
        return group;
      }

      function respawnEnemy() {
        if (enemies.length < CONFIG.enemyCount) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 30 + Math.random() * 20;
          const pos = new THREE.Vector3(
            Math.cos(angle) * distance,
            0,
            Math.sin(angle) * distance
          );
          const enemy = createUnit(false, 'GOBLIN', pos);
          enemies.push(enemy);
        }
      }

      function showFloatingText(text, pos, color) {
        const div = document.createElement('div');
        div.textContent = text;
        div.style.position = 'fixed';
        div.style.color = color;
        div.style.fontSize = '20px';
        div.style.fontWeight = 'bold';
        div.style.pointerEvents = 'none';
        div.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';

        const vec = pos.clone();
        vec.project(camera);
        const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-(vec.y * 0.5) + 0.5) * window.innerHeight;

        div.style.left = x + 'px';
        div.style.top = y + 'px';
        div.style.transform = 'translate(-50%, -50%)';

        document.getElementById('ui-layer').appendChild(div);

        let opacity = 1;
        const interval = setInterval(() => {
          opacity -= 0.05;
          div.style.opacity = opacity.toString();
          div.style.transform = `translate(-50%, calc(-50% - ${(1 - opacity) * 30}px))`;

          if (opacity <= 0) {
            clearInterval(interval);
            div.remove();
          }
        }, 50);
      }

      function playerAttack() {
        const now = Date.now();
        if (now - player.userData.lastAttack < 500) return;

        player.userData.lastAttack = now;

        const closestEnemy = enemies
          .filter((en) => en.userData.hp > 0)
          .sort(
            (a, b) =>
              player.position.distanceTo(a.position) -
              player.position.distanceTo(b.position)
          )[0];

        if (closestEnemy && player.position.distanceTo(closestEnemy.position) < 5) {
          damageEnemy(
            closestEnemy,
            stats.dmg + Math.random() * 5,
            true
          );
          showFloatingText('HIT!', closestEnemy.position, 'yellow');
        }
      }

      function damageEnemy(en, amount, fromPlayer) {
        en.userData.hp -= amount;

        // Actualizar barra HTML
        if (en.userData.hpBarElement) {
          const pct = Math.max(0, en.userData.hp / en.userData.maxHp);
          const fill = en.userData.hpBarElement.querySelector('.hp-fill');
          if (fill) {
            fill.style.width = pct * 100 + '%';
          }
          en.userData.hpBarElement.style.display = 'block';
        }

        // Texto flotante
        if (fromPlayer) showFloatingText(`-${Math.floor(amount)}`, en.position, 'red');

        if (en.userData.hp <= 0) {
          killEnemy(en, fromPlayer);
        }
      }

      function killEnemy(en, killedByPlayer) {
        en.position.y = -100;

        // Ocultar barra de vida
        if (en.userData.hpBarElement) {
          en.userData.hpBarElement.style.display = 'none';
        }

        if (killedByPlayer) {
          const xp = en.userData.lvl * 20;
          stats.xp += xp;
          showFloatingText(`+${xp} XP`, player.position, 'gold');
          checkLevelUp();
        }

        // Respawn tras tiempo
        setTimeout(() => {
          // Limpiar barra HTML
          if (en.userData.hpBarElement) {
            en.userData.hpBarElement.remove();
          }
          scene.remove(en);
          const idx = enemies.indexOf(en);
          if (idx > -1) enemies.splice(idx, 1);
          respawnEnemy();
        }, CONFIG.respawnTime);
      }

      function checkLevelUp() {
        if (stats.xp >= stats.xpMax) {
          stats.xp -= stats.xpMax;
          stats.level++;
          stats.xpMax = Math.floor(stats.xpMax * 1.1);
          stats.maxHp += 20;
          stats.hp = stats.maxHp;
          stats.dmg += 5;
          showFloatingText('LEVEL UP!', player.position, 'lime');
          updateHUD();
        }
      }

      function useSkill(skillName) {
        const now = Date.now();

        if (skillName === 'dash') {
          if (now - player.userData.skillCooldown.dash < 1000) return;
          player.userData.skillCooldown.dash = now;

          const forward = new THREE.Vector3(0, 0, 1);
          forward.applyQuaternion(player.quaternion);
          player.position.addScaledVector(forward, 15);

          const closestEnemy = enemies
            .filter((en) => en.userData.hp > 0)
            .sort(
              (a, b) =>
                player.position.distanceTo(a.position) -
                player.position.distanceTo(b.position)
            )[0];

          if (
            closestEnemy &&
            player.position.distanceTo(closestEnemy.position) < 8
          ) {
            damageEnemy(closestEnemy, stats.dmg * 1.5, true);
          }
        }
      }

      function handleEnemyAI() {
        enemies.forEach((en) => {
          if (en.userData.hp <= 0) return;

          const distToPlayer = en.position.distanceTo(player.position);

          // Perseguir al jugador
          if (distToPlayer > 1) {
            const dir = player.position
              .clone()
              .sub(en.position)
              .normalize();
            en.position.addScaledVector(dir, en.userData.speed);

            // Rotar hacia el jugador
            const angle = Math.atan2(dir.x, dir.z);
            en.rotation.y = angle;
          }

          // Atacar si está cerca
          if (distToPlayer < 2) {
            const now = Date.now();
            if (now - en.userData.lastAttack > 1000) {
              en.userData.lastAttack = now;
              stats.hp -= en.userData.dmg;
              showFloatingText(`-${en.userData.dmg}`, player.position, 'orange');
              updateHUD();
            }
          }
        });
      }

      function updateEnemyHPBars() {
        enemies.forEach((en) => {
          if (!en.userData.hpBarElement || en.userData.hp <= 0) return;

          // Proyectar posición 3D a pantalla 2D
          const vec = en.position.clone();
          vec.y += 2.5;
          vec.project(camera);

          const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-(vec.y * 0.5) + 0.5) * window.innerHeight;

          en.userData.hpBarElement.style.left = x + 'px';
          en.userData.hpBarElement.style.top = y + 'px';
        });
      }

      function updateHUD() {
        document.getElementById('level').textContent = stats.level;
        document.getElementById('xp').textContent = stats.xp;
        document.getElementById('xp-max').textContent = stats.xpMax;
        document.getElementById('xp-fill').style.width = (stats.xp / stats.xpMax) * 100 + '%';
        document.getElementById('hp').textContent = Math.max(0, stats.hp);
        document.getElementById('hp-max').textContent = stats.maxHp;
        document.getElementById('hp-fill').style.width = Math.max(0, (stats.hp / stats.maxHp) * 100) + '%';
        document.getElementById('dmg').textContent = stats.dmg;
      }

      function setupInputs() {
        // Mouse click para atacar
        document.addEventListener('click', playerAttack);

        // Teclado
        const keys = {};

        window.addEventListener('keydown', (e) => {
          keys[e.key.toLowerCase()] = true;

          if (e.key === ' ') useSkill('dash');
          if (e.key === 'Enter') playerAttack();
        });

        window.addEventListener('keyup', (e) => {
          keys[e.key.toLowerCase()] = false;
        });

        // Actualizar posición del jugador
        setInterval(() => {
          const forward = new THREE.Vector3(0, 0, -1);
          const right = new THREE.Vector3(1, 0, 0);

          if (keys['w']) player.position.addScaledVector(forward, 0.3);
          if (keys['s']) player.position.addScaledVector(forward, -0.3);
          if (keys['d']) player.position.addScaledVector(right, 0.3);
          if (keys['a']) player.position.addScaledVector(right, -0.3);

          // Límites del mapa
          player.position.x = Math.max(
            -CONFIG.mapSize / 2,
            Math.min(CONFIG.mapSize / 2, player.position.x)
          );
          player.position.z = Math.max(
            -CONFIG.mapSize / 2,
            Math.min(CONFIG.mapSize / 2, player.position.z)
          );
        }, 16);

        // Rotación de cámara con mouse
        let mouseX = 0;
        document.addEventListener('mousemove', (e) => {
          mouseX = (e.clientX / window.innerWidth) * 2 - 1;
        });

        // Actualizar cámara
        setInterval(() => {
          const cameraDistance = 20;
          const cameraHeight = 10;

          camera.position.x = player.position.x - Math.sin(mouseX * 0.5) * cameraDistance;
          camera.position.y = player.position.y + cameraHeight;
          camera.position.z = player.position.z - Math.cos(mouseX * 0.5) * cameraDistance;

          camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
        }, 16);
      }

      function animate() {
        requestAnimationFrame(animate);

        handleEnemyAI();
        updateEnemyHPBars();

        renderer.render(scene, camera);
      }

      // INICIALIZACIÓN
      setupInputs();

      for (let i = 0; i < CONFIG.enemyCount; i++) {
        respawnEnemy();
      }

      updateHUD();
      animate();

      // Manejo de resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>